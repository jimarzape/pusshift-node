import unfetch from 'isomorphic-unfetch';
import type { SerializedValue } from '@ergodark/types';
export declare type FetchConfig = Omit<RequestInit, 'body'> & {
    swr?: boolean;
    rejects?: boolean;
    ignoreParseErrors?: boolean;
    body?: Record<string, unknown>;
};
/**
 * Re-export these
 */
export { unfetch };
/**
 * Get the default config object merged in during all `fetch()` calls.
 */
export declare function getGlobalFetchConfig(): FetchConfig;
/**
 * Set the default config object merged in during all `fetch()` calls.
 */
export declare function setGlobalFetchConfig(config: FetchConfig): void;
/**
 * Performs an isomorphic (un)fetch and returns the JsonType response or
 * immediately rejects. Hence, `error` will always be undefined and `json` will
 * always be defined.
 *
 * @example
 * ```
 * try {
 *   const { json } = fetch('https://some.resource.com/data.json', {
 *     rejects: true
 *   });
 *   doSomethingWith(json);
 * } catch(e) {
 *   // ...
 * }
 * ```
 *
 * @throws When a non-2xx response is received
 */
export declare function fetch<JsonType extends SerializedValue = Record<string, unknown>, ErrorType extends SerializedValue = JsonType>(url: string, config: Omit<FetchConfig, 'rejects' | 'swr'> & {
    rejects: true;
    swr?: false;
}): Promise<{
    res: Response;
    json: JsonType;
    error: undefined;
}>;
export declare namespace fetch {
    export var get: typeof fetch;
    export var put: typeof fetch;
    var _a: typeof fetch;
    export var post: typeof fetch;
    export var swr: (key: string) => Promise<Record<string, unknown>>;
    export { _a as delete };
}
/**
 * Performs an isomorphic (un)fetch and returns the JsonType response or throws
 * as SWR expects.
 *
 * @example
 * ```
 *   const { data: json, error } = useSwr('api/endpoint', fetch.swr);
 *   // Or:                  ... = useSwr('api/endpoint', key => fetch(key, { swr: true }));
 *
 *   if(error) <div>Error: {error.message}</div>;
 *   return <div>Hello, your data is: {json.data}</div>;
 * ```
 *
 * @throws When a non-2xx response is received
 * @see https://swr.vercel.app
 */
export declare function fetch<JsonType extends SerializedValue = Record<string, unknown>, ErrorType extends SerializedValue = JsonType>(url: string, config: Omit<FetchConfig, 'swr' | 'rejects'> & {
    swr: true;
    rejects?: false;
}): Promise<JsonType>;
export declare namespace fetch {
    export var get: typeof fetch;
    export var put: typeof fetch;
    var _a: typeof fetch;
    export var post: typeof fetch;
    export var swr: (key: string) => Promise<Record<string, unknown>>;
    export { _a as delete };
}
/**
 * Performs an isomorphic (un)fetch, following redirects as necessary.
 *
 * @returns
 * 1) A Response object `res` and parsed response body `json`
 * 2) `error` (`undefined` on 2xx response)
 *
 * Note: `json` is undefined on non-2xx responses while `error` is undefined on
 * 2xx responses.
 *
 * @example
 * ```
 *   const { json, error } = fetch.post<{ data: number }, { message: string }>(
 *     'api/endpoint',
 *     {
 *       headers: { key: apiKey },
 *       body: requestData,
 *       rejects: false // false is the default
 *     }
 *   );
 *
 *   if(error) throw error.message;
 *   return json.data;
 * ```
 *
 * @throws
 * When parsing the body for JSON content fails and `{ ignoreParseErrors: true }`
 */
export declare function fetch<JsonType extends SerializedValue = Record<string, unknown>, ErrorType extends SerializedValue = JsonType>(url: string, config?: FetchConfig): Promise<{
    res: Response;
    json: JsonType | undefined;
    error: ErrorType | undefined;
}>;
export declare namespace fetch {
    export var get: typeof fetch;
    export var put: typeof fetch;
    var _a: typeof fetch;
    export var post: typeof fetch;
    export var swr: (key: string) => Promise<Record<string, unknown>>;
    export { _a as delete };
}
